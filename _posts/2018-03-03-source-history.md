---
layout: blog
title: 'NHN 엔터 기술교육 소스코드 history'
date: 2018-03-03 22:19:34
categories: blog
tags: 
image: 
lead_text: 
---


# 소스코드 변천사

스프링 프로젝트를 처음 시작할 떄 mybatis를 사용하였다.  
필요한 sql을 xml파일에 작성 한 후 작성한 도메인으로 값을 넘기거나 받아왔다.  
문득 이러한 도메인을 자동으로 생성할 방법이 없을까? 라는 의문이 들었고, 바로 구글링을 해본 결과...  
![]({{ "images/basecamp-final/googling-mybatis-auto-generate.png" | absolute_url}}}  


mybatis-generator라는것을 찾았고, 바로 사용하였다.  
그리고 아래의 코드가 생성되었다.  
  

```java
public class MailDto{
	
	private String mailCode;
	....

	/**
	 * This method was generated by MyBatis Generator. This method corresponds to the database table wm_mail
	 * @mbg.generated  Wed Jan 31 11:10:47 KST 2018
	 */
	public MailVO( ... ) { ... }

	/**
	 * This method was generated by MyBatis Generator. This method returns the value of the database column wm_mail.mail_code
	 * @return  the value of wm_mail.mail_code
	 * @mbg.generated  Wed Jan 31 11:10:47 KST 2018
	 */
	public String getMailCode() {
		return mailCode;
	}

	/**
	 * This method was generated by MyBatis Generator. This method sets the value of the database column wm_mail.mail_code
	 * @param mailCode  the value for wm_mail.mail_code
	 * @mbg.generated  Wed Jan 31 11:10:47 KST 2018
	 */
	public void setMailCode(String mailCode) {
		this.mailCode = mailCode;
	}

	....
}

```


처음 사용했을때는 무척 편리하였다.  
기본적인 sql문이 생성된것은 물론이고, 각 테이블에 맞는 도메인을 생성할 필요가 없었다.  
그리고, 테이블을 수정하게 된다 하더라도 다시 생성해주면 될 문제였다.  

이후 첫번쨰 프로젝트 발표를 마친 뒤, 정적 코드리뷰를 진행하였고, 각 도메인에 이런저런 기능을 추가하면서 문제가 되기 시작하였다.  
생성자를 추가하고, 각각 기능을 넣었다. 이때, 자동으로 생성된 코드에 손을 대기 싫어 아래와 같이 괴상한 코드가 탄생되었다.  
  
  
```java
public class MailExtendedDto extends MailDto {
	public List<String> getReceiverArrayList() {...}
	
	public MailExtendedDto() { ... }

	public MailExtendedDto( SomeOtherParameter ...) { ... }
	
	public String toStringOriginalMessageForm() { ... }
	
	public String toStringForCLI() { ... }
	
	public static MailDto getFailMailObject( ... ) { ... }

	....
}

```


코드도 이상하지만, 의미도 맞지 않았다. 데이터가 모두 db table 중심으로 돌아갔다.  
어떠한 컨트롤러의 파라미터는 아래와 같았다.  


```java
public class WritemailController{
	....

	@PostMapping("/send")
	public String send(Model model, @RequestParam(value = "parentMailid", required = true) String parentMailid,
			@RequestParam(value = "type", required = true) String writeType,
			@RequestParam(value = "receiverList", required = true) String receiverList,
			@RequestParam(value = "ccList", required = true) String ccList,
			@RequestParam(value = "title", required = true) String title,
			@RequestParam(value = "validDate", required = true) String validDate,
			@RequestParam(value = "content", required = true) String content,
			@RequestParam(value = "filePath", required = false) List<String> filePath,
			@RequestParam(value = "fileName", required = false) List<String> fileName,
			@RequestParam(value = "fileSize", required = false) List<Integer> fileSize
	) throws Exception {
		......
	}
}
```


많고, 복잡하고.......  
이후에 각각 의미에 맞는 도메인을 사용하고, 위에서 생성된 코드는 DB에 저장할때만 사용하려고 바꾸기 시작했다.  
그리고 이러한 객체의 생성을 쉽게 하기 위해 lombok을 도입하였고, mybatis-generator에도 lombok plugin이라는것을 찾아내어 적용하였다.  
  
  
```java
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class WrittenMail {
	private Integer parentMailId;
	private String writeType;
	private String to;
	private String cc;
	private Date validDate;
	private String title;
	private String content;
	private AttatchedFiles attatchedFiles;
}

```



```java
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class MailDto {
    /**
     *
     * This field was generated by MyBatis Generator.
     * This field corresponds to the database column wm_mail.mail_id
     *
     * @mbg.generated Tue Feb 20 00:52:16 KST 2018
     */
    private Integer mailId;
     .....

```
  
  
Controller의 파라미터도 아래와 같이 깔끔하게 바뀌었다.  
  
```java
public class WriteMailController{ 
	....

	@PostMapping("/send")
	public void sendMail(@RequestBody WrittenMail mail) {
		....
	}
}
```
  
자 이제 실제 db에 저장하기 위해 db값에 매칭되는 dto로 바꿔줘야 한다.  
어떻게 만들지? 라는 고민을 하다 멤버함수로 변환 함수를 만들었다.
  
```java
public class WeriteMail{
	....

	public MailDto createMailDto(){
		return MailDto.builder()
					.......
					.bulid()
	}

}

```
  

이러한 코드를 작성하면서 이런 생각이 들었다.  
각각의 사용되는 클래스에 모두 db에 매칭되는 dto로의 변환을 만들어야하나??  
물리적인 데이터 저장소(컬럼명이나 저장 방법 등등...) 이 바뀌면 이 객체의 멤버 함수도 같이 바뀌어야 하나?  
그렇다면 결합돋가 너무 높은게 아닐까??  
  
  
이러한 고민 끝에 각각의 도메인의 변환을 다른 인터페이스에 위임하여 진행하자는 생각이 들었다.

![]({{ "images/basecamp-final/converter.png" | absolute_url}}}  
이렇게 모든 도메인들은 DataConver를 거쳐서 다른 도메인으로 변환되게 하였다.  
  
자, 이제 타입의 변환이 필요할 때 필요한 converter를 사용하면 된다.  
하지만 converter의 실제 구현체를 가져올 필요가 있을까? 라는 의문에서 팩토리를 만들었다.

```java
@Component
public class DataConverterFactory {
	....
	
	public DataConverter getConverter(Class from, Class to) {
		if (from == WritedMail.class && to == MailDto.class) {
			return writedMailConverter;
		} else if (from == ReceivedMail.class && to == MailDto.class) {
			return receivedMailConverter;
		} else if (from == MailQueueDto.class && to == MailDto.class) {
			return mailQueueDtoToReceivedMailListConverter;
		} else if( .... )

		throw new ConverterNotFoundException();
	}	
}
```

처음 작성한 Factory소스.. if문으로 도배되어있고, 새로운 converter가 만들어지면 factory에 추가해줘야 했다.  
해결방법을 찾지 못하다가, 정명주 책임님의 도움으로 아래와 같이 소스를 바꾸게 되었다.
factory에서 어떤 값이 있는지는 외부에서 주입받고, factory는 conver를 넘겨주는 간결한 코드가 되었다. 
또한, generic을 이용하여 Object를 이용하지 않고, 좀더 타입안정성을 추구할 수 있게 되었다.

```java
@Configuration
public class DataConverterConfig {
	....

	@Bean(name="dataConverterRoutingMap")
	public Map<DataConverterRouteKey , DataConverter<?, ?>> dataConverterRoutingMap() {
		Map<DataConverterRouteKey, DataConverter<?,?>> map = new HashMap<>();
		map.put(new DataConverterRouteKey(SendableMail.class, MailDto.class), receivedMailToMailDtoConverter);
		
		...
		
		return map;
	}
}

@Component
public class DataConverterFactory {

	@Autowired
	@Qualifier("dataConverterRoutingMap")
	Map<DataConverterRouteKey , DataConverter<?, ?>> routingMap;
	
	public <I, O> DataConverter<I, O> getDataConverter(Class<I> from, Class<O> to) {
		DataConverter<I, O> converter = (DataConverter<I, O>) routingMap.get(new DataConverterRouteKey(from, to));
		if(converter == null) {
			throw new ConverterNotFoundException();
		}
		return converter;
	}
}

```
  
이제 컨버터를 이용하면 내가 원하는 객체로 언제 어디서든 바꿀수 있다.  
그 결과 서비스 로직은 아래와같이 바뀐다.

```java
@Service
public class WriteMailService{

	@Autowired
	DataConverterFactory dataConverterFactory;

	....

	private void addSentMail(WrittendMail mail) throws DataConvertException  {
		DataConverter converter = dataConverterFactory.getDataConverter(WritedMail.class , MailDto.class);
		MailDto dto = (MailDto) converter.convert(mail);
		mailMapper.insert(dto);
	}
}


```

욕심이 많아서 그런지, 아직도 뭔가 어색했다.  
내가 하고싶은것은 writtenMail을 저장하는것인대, db에 맞게 변환하는 로직을 service에 있는게 너무 어색했다.  
그래서, Dao를 만들었다.  

```java
@Service
public class WriteMailService{
	....

	public void saveSentMail(String userId, WrittenMail mail) {
		writtenMailDao.insert(mail);
	}
}


@Component
public class WrittenMailDao{
	
	private DataConverterFactory dataConverterFactory;
	
	....

	public void insert(WrittenMail mail) {
		MailDto dto = dataConverterFactory
				.getDataConverter(WrittenMail.class, MailDto.class)
				.convert(mail);
		mailMapper.insert(dto);
	}
}

```

우리TF가 진행했던 소스는 이렇게 바뀌어왔다.  
우리가 다같이 했던 고민은 이미 많은 사람들이 해왔겠지만,  
어떻게 구현하는게 더 좋을까 생각해가며, 직접 구현해봤던 이 경험들은 정말 값진 경험들이다.

